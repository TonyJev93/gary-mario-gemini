<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D 마리오 스타일 - Phase 5</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: #0f172a;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        canvas {
            border: 4px solid #334155;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            background-color: #5C94FC;
            image-rendering: pixelated;
        }
        .ui-panel {
            margin-top: 15px;
            text-align: center;
            background: rgba(15, 23, 42, 0.9);
            padding: 12px 30px;
            border-radius: 16px;
            border: 1px solid #334155;
            min-width: 550px;
            backdrop-filter: blur(5px);
        }
    </style>
</head>
<body>

<div class="mb-2 text-center">
    <h1 class="text-4xl font-black mb-1 text-transparent bg-clip-text bg-gradient-to-r from-red-500 to-yellow-500">Super Runner 2D</h1>
    <p class="text-slate-400 text-sm tracking-widest uppercase">Phase 5: 파티클 효과 & 시각적 피드백</p>
</div>

<canvas id="gameCanvas"></canvas>

<div class="ui-panel">
    <div class="flex gap-10 justify-around mb-1">
        <div class="flex flex-col">
            <span class="text-xs text-slate-500 uppercase">Score</span>
            <span id="scoreVal" class="text-2xl font-black text-yellow-400">0</span>
        </div>
        <div class="flex flex-col">
            <span class="text-xs text-slate-500 uppercase">Form</span>
            <span id="formVal" class="text-2xl font-black text-blue-400">Small</span>
        </div>
        <div class="flex flex-col">
            <span class="text-xs text-slate-500 uppercase">Status</span>
            <span id="statusVal" class="text-2xl font-black text-green-400">Ready</span>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // 게임 상수
    const GRAVITY = 0.6;
    const FRICTION = 0.85;
    const JUMP_FORCE = -13;
    const MOVE_SPEED = 4.5;
    const TILE_SIZE = 40;

    canvas.width = 800;
    canvas.height = 400;

    // 게임 상태
    const keys = {};
    let score = 0;
    let isGameOver = false;
    let isLevelCleared = false;
    let screenShake = 0;

    // 파티클 시스템
    let particles = [];
    class Particle {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.size = Math.random() * 5 + 2;
            this.speedX = (Math.random() - 0.5) * 8;
            this.speedY = (Math.random() - 0.5) * 8;
            this.color = color;
            this.life = 1.0;
            this.decay = Math.random() * 0.05 + 0.02;
        }
        update() {
            this.x += this.speedX;
            this.y += this.speedY;
            this.life -= this.decay;
        }
        draw() {
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x - camera.x, this.y, this.size, this.size);
            ctx.globalAlpha = 1.0;
        }
    }

    // 텍스트 파티클 (점수 표시)
    let textParticles = [];
    class TextParticle {
        constructor(x, y, text, color) {
            this.x = x;
            this.y = y;
            this.text = text;
            this.color = color;
            this.life = 1.0;
            this.speedY = -1;
        }
        update() {
            this.y += this.speedY;
            this.life -= 0.02;
        }
        draw() {
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.font = "bold 16px Arial";
            ctx.fillText(this.text, this.x - camera.x, this.y);
            ctx.globalAlpha = 1.0;
        }
    }

    function createExplosion(x, y, color, count = 10) {
        for (let i = 0; i < count; i++) {
            particles.push(new Particle(x, y, color));
        }
    }

    function createScoreText(x, y, scoreVal) {
        textParticles.push(new TextParticle(x, y, "+" + scoreVal, "#FFFF00"));
        score += scoreVal;
        document.getElementById('scoreVal').innerText = score;
    }

    // 카메라
    const camera = {
        x: 0,
        update(playerX) {
            let targetX = playerX - canvas.width / 3;
            if (targetX < 0) targetX = 0;
            const worldWidth = worldMap[0].length * TILE_SIZE;
            if (targetX > worldWidth - canvas.width) targetX = worldWidth - canvas.width;
            this.x = targetX;
        }
    };

    // 플레이어
    const player = {
        x: 80,
        y: 200,
        width: 30,
        height: 38,
        velX: 0,
        velY: 0,
        jumping: false,
        facingRight: true,
        isSuper: false,
        invincible: 0,
        updateSize() {
            if (this.isSuper) {
                this.height = 56;
                document.getElementById('formVal').innerText = "Super";
                document.getElementById('formVal').className = "text-2xl font-black text-red-500";
            } else {
                this.height = 38;
                document.getElementById('formVal').innerText = "Small";
                document.getElementById('formVal').className = "text-2xl font-black text-blue-400";
            }
        },
        draw() {
            if (this.invincible % 4 > 1) return;
            ctx.save();
            ctx.translate(-camera.x, 0);

            // 캐릭터 본체
            ctx.fillStyle = this.isSuper ? '#CC0000' : '#FF3333';
            // 점프 시 약간 길어지는 연출
            let drawH = this.height;
            let drawY = this.y;
            if (this.jumping) {
                drawH += 4;
                drawY -= 4;
            }
            ctx.fillRect(this.x, drawY, this.width, drawH);

            // 모자
            ctx.fillStyle = '#880000';
            ctx.fillRect(this.x - 2, drawY, this.width + 4, 10);

            // 눈
            ctx.fillStyle = 'white';
            let eyeX = this.facingRight ? this.x + 20 : this.x + 4;
            ctx.fillRect(eyeX, drawY + 12, 6, 8);

            ctx.restore();
        }
    };

    // 적 캐릭터
    class Enemy {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.width = 36;
            this.height = 36;
            this.velX = 1.8;
            this.dead = false;
        }
        update(platforms) {
            if (this.dead) return;
            this.x += this.velX;
            let hitWall = false;
            let onEdge = true;
            for (let plat of platforms) {
                if (this.x < plat.x + plat.width && this.x + this.width > plat.x &&
                    this.y < plat.y + plat.height && this.y + this.height > plat.y) hitWall = true;
                let checkX = this.velX > 0 ? this.x + this.width : this.x;
                if (checkX >= plat.x && checkX <= plat.x + plat.width &&
                    this.y + this.height + 2 >= plat.y && this.y + this.height + 2 <= plat.y + plat.height) onEdge = false;
            }
            if (hitWall || onEdge) this.velX *= -1;
        }
        draw() {
            if (this.dead) return;
            ctx.save();
            ctx.translate(-camera.x, 0);
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.moveTo(this.x, this.y + this.height);
            ctx.quadraticCurveTo(this.x + this.width/2, this.y - 10, this.x + this.width, this.y + this.height);
            ctx.fill();
            ctx.restore();
        }
    }

    // 아이템 (버섯)
    class Mushroom {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.width = 30;
            this.height = 30;
            this.velX = 2.5;
            this.velY = -5; // 나올 때 튀어오름
            this.active = true;
        }
        update(platforms) {
            this.velY += GRAVITY;
            this.x += this.velX;
            this.y += this.velY;
            for (let plat of platforms) {
                if (this.x < plat.x + plat.width && this.x + this.width > plat.x &&
                    this.y < plat.y + plat.height && this.y + this.height > plat.y) {
                    if (this.velY > 0) { this.y = plat.y - this.height; this.velY = 0; }
                    else { this.velX *= -1; }
                }
            }
        }
        draw() {
            ctx.save();
            ctx.translate(-camera.x, 0);
            ctx.fillStyle = '#FF6666';
            ctx.beginPath(); ctx.arc(this.x + 15, this.y + 12, 15, Math.PI, 0); ctx.fill();
            ctx.fillStyle = '#F5F5DC'; ctx.fillRect(this.x + 8, this.y + 12, 14, 18);
            ctx.restore();
        }
    }

    const platforms = [];
    const coins = [];
    const enemies = [];
    const mushrooms = [];
    let goal = { x: 0, y: 0, width: 10, height: 280 };

    const worldMap = [
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,2,6,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,3,0,0,0,0,4,0,0,2,2,2,2,2,2,0,0,0,0,2,2,4,0,0,0,0,3,3,0,0,0,0,0,0,0,0,0,0],
        [0,0,2,2,2,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0],
        [1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1],
        [1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1]
    ];

    function initLevel() {
        platforms.length = 0; coins.length = 0; enemies.length = 0; mushrooms.length = 0;
        particles = []; textParticles = [];
        isLevelCleared = false; isGameOver = false;
        player.isSuper = false; player.invincible = 0; player.updateSize();

        for (let r = 0; r < worldMap.length; r++) {
            for (let c = 0; c < worldMap[r].length; c++) {
                const type = worldMap[r][c];
                const x = c * TILE_SIZE; const y = r * TILE_SIZE;
                if (type === 1 || type === 2 || type === 6) platforms.push({ x, y, width: TILE_SIZE, height: TILE_SIZE, type, hit: false });
                else if (type === 3) coins.push({ x: x + 10, y: y + 10, width: 20, height: 20, collected: false });
                else if (type === 4) enemies.push(new Enemy(x, y + 4));
                else if (type === 5) goal = { x: x + 15, y: y - 240, width: 10, height: 280 };
            }
        }
    }

    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => keys[e.code] = false);

    function update() {
        if (isGameOver || isLevelCleared) return;
        if (player.invincible > 0) player.invincible--;
        if (screenShake > 0) screenShake--;

        // 이동
        if (keys['ArrowLeft'] || keys['KeyA']) {
            if (player.velX > -MOVE_SPEED) player.velX -= 0.8;
            player.facingRight = false;
            if (!player.jumping && Math.random() > 0.7) particles.push(new Particle(player.x + player.width, player.y + player.height, '#fff'));
        }
        if (keys['ArrowRight'] || keys['KeyD']) {
            if (player.velX < MOVE_SPEED) player.velX += 0.8;
            player.facingRight = true;
            if (!player.jumping && Math.random() > 0.7) particles.push(new Particle(player.x, player.y + player.height, '#fff'));
        }
        if ((keys['ArrowUp'] || keys['Space'] || keys['KeyW']) && !player.jumping) {
            player.jumping = true; player.velY = JUMP_FORCE;
            createExplosion(player.x + player.width/2, player.y + player.height, '#fff', 5);
        }

        player.velX *= FRICTION;
        player.velY += GRAVITY;
        player.x += player.velX;
        player.y += player.velY;

        camera.update(player.x);

        // 플랫폼 충돌
        for (let plat of platforms) {
            if (player.x < plat.x + plat.width && player.x + player.width > plat.x &&
                player.y < plat.y + plat.height && player.y + player.height > plat.y) {
                if (player.velY > 0 && player.y + player.height - player.velY <= plat.y) {
                    player.jumping = false; player.velY = 0; player.y = plat.y - player.height;
                } else if (player.velY < 0 && player.y - player.velY >= plat.y + plat.height) {
                    player.velY = 0; player.y = plat.y + plat.height;
                    if (plat.type === 6 && !plat.hit) {
                        plat.hit = true; screenShake = 5;
                        createExplosion(plat.x + plat.width/2, plat.y, '#FFD700', 8);
                        mushrooms.push(new Mushroom(plat.x + 5, plat.y - 40));
                    }
                } else {
                    if (player.velX > 0) player.x = plat.x - player.width;
                    else if (player.velX < 0) player.x = plat.x + plat.width;
                }
            }
        }

        // 적 충돌
        enemies.forEach(enemy => {
            if (enemy.dead) return;
            enemy.update(platforms);
            if (player.x < enemy.x + enemy.width && player.x + player.width > enemy.x &&
                player.y < enemy.y + enemy.height && player.y + player.height > enemy.y) {
                if (player.velY > 0 && player.y + player.height < enemy.y + 20) {
                    enemy.dead = true; player.velY = JUMP_FORCE / 1.5;
                    createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#8B4513', 15);
                    createScoreText(enemy.x, enemy.y, 500);
                    screenShake = 3;
                } else if (player.invincible === 0) {
                    if (player.isSuper) {
                        player.isSuper = false; player.updateSize(); player.invincible = 60;
                        screenShake = 10; createExplosion(player.x, player.y, '#ff0000', 20);
                    } else triggerGameOver();
                }
            }
        });

        // 버섯 & 코인
        mushrooms.forEach((m, i) => {
            m.update(platforms);
            if (player.x < m.x + m.width && player.x + player.width > m.x &&
                player.y < m.y + m.height && player.y + player.height > m.y) {
                mushrooms.splice(i, 1); player.isSuper = true; player.updateSize();
                createScoreText(m.x, m.y, 1000); createExplosion(m.x, m.y, '#FF6666', 15);
            }
        });

        coins.forEach(coin => {
            if (!coin.collected && player.x < coin.x + coin.width && player.x + player.width > coin.x &&
                player.y < coin.y + coin.height && player.y + player.height > coin.y) {
                coin.collected = true; createScoreText(coin.x, coin.y, 100);
                createExplosion(coin.x + 10, coin.y + 10, '#FFD700', 5);
            }
        });

        // 파티클 업데이트
        particles.forEach((p, i) => { p.update(); if (p.life <= 0) particles.splice(i, 1); });
        textParticles.forEach((tp, i) => { tp.update(); if (tp.life <= 0) textParticles.splice(i, 1); });

        if (player.x < goal.x + goal.width && player.x + player.width > goal.x &&
            player.y < goal.y + goal.height && player.y + player.height > goal.y) triggerClear();
        if (player.y > canvas.height) triggerGameOver();
    }

    function triggerGameOver() {
        isGameOver = true; document.getElementById('statusVal').innerText = "Game Over";
        document.getElementById('statusVal').className = "text-2xl font-black text-red-600";
        screenShake = 15; setTimeout(resetGame, 1500);
    }

    function triggerClear() {
        isLevelCleared = true; document.getElementById('statusVal').innerText = "Cleared!";
        document.getElementById('statusVal').className = "text-2xl font-black text-yellow-400 animate-pulse";
        setTimeout(resetGame, 3000);
    }

    function resetGame() {
        player.x = 80; player.y = 200; player.velX = 0; player.velY = 0; score = 0;
        document.getElementById('scoreVal').innerText = "0";
        document.getElementById('statusVal').innerText = "Adventure";
        document.getElementById('statusVal').className = "text-2xl font-black text-green-400";
        initLevel();
    }

    function draw() {
        ctx.save();
        if (screenShake > 0) ctx.translate((Math.random()-0.5)*screenShake, (Math.random()-0.5)*screenShake);

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 배경 구름
        ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
        for(let i=0; i<8; i++) {
            let cx = (i * 400 - camera.x * 0.2) % 3200;
            ctx.beginPath(); ctx.arc(cx, 80, 40, 0, Math.PI*2); ctx.arc(cx+30, 70, 30, 0, Math.PI*2); ctx.fill();
        }

        ctx.save(); ctx.translate(-camera.x, 0);
        platforms.forEach(plat => {
            ctx.fillStyle = plat.type === 6 ? (plat.hit ? '#475569' : '#fbbf24') : (plat.type === 1 ? '#78350f' : '#b45309');
            ctx.fillRect(plat.x, plat.y, plat.width, plat.height);
            ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.strokeRect(plat.x, plat.y, plat.width, plat.height);
            if (plat.type === 6 && !plat.hit) { ctx.fillStyle = 'white'; ctx.font = 'bold 20px Arial'; ctx.fillText('?', plat.x + 14, plat.y + 27); }
        });

        ctx.fillStyle = '#1e293b'; ctx.fillRect(goal.x, goal.y, goal.width, goal.height);
        ctx.fillStyle = '#facc15'; ctx.beginPath(); ctx.moveTo(goal.x+10, goal.y); ctx.lineTo(goal.x+60, goal.y+25); ctx.lineTo(goal.x+10, goal.y+50); ctx.fill();

        coins.forEach(c => { if (!c.collected) { ctx.fillStyle = '#fbbf24'; ctx.beginPath(); ctx.arc(c.x+10, c.y+10, 8, 0, Math.PI*2); ctx.fill(); } });
        mushrooms.forEach(m => m.draw());
        ctx.restore();

        enemies.forEach(e => e.draw());
        player.draw();
        particles.forEach(p => p.draw());
        textParticles.forEach(tp => tp.draw());

        if (isGameOver || isLevelCleared) {
            ctx.fillStyle = 'rgba(15,23,42,0.7)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white'; ctx.font = 'bold 50px Arial'; ctx.textAlign = 'center';
            ctx.fillText(isLevelCleared ? 'STAGED CLEARED' : 'YOU DIED', canvas.width/2, canvas.height/2);
        }
        ctx.restore();
    }

    function gameLoop() { update(); draw(); requestAnimationFrame(gameLoop); }
    window.onload = () => { initLevel(); gameLoop(); };
</script>
</body>
</html>